# 十一到十五週心得

## 前情提要

現在時間： 22 週 / 我的進度： 20 週
人真的不能拖，居然已經到了要寫 20 週心得的日子了（閉眼）

**心得速記：**
感謝認真寫每日進度ㄉ過去ㄉ我，找不到像之前那樣可以貫穿的主題，以下內容可視為生菜每日進度ㄉ精華集 (???)
[怕跑版ㄉ部落格版](https://v61265.coderbridge.io/2020/11/14/MTR04-week15/)

**自我檢測：**
給未來求職前的自己作為回頭複習ㄉ筆記
or（如果我寫到一半發懶）
直接想像自己在面試時被問到，我會怎麼回～
[怕跑版ㄉ部落格](https://v61265.coderbridge.io/2020/10/17/week15%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E4%BA%86%E5%97%8E%EF%BC%9F%EF%BC%8D%E8%87%AA%E6%88%91%E6%AA%A2%E6%B8%AC/)


## 學了什麼

1. Session 與 Cookie 的差異
2. 資訊安全（Hashing、SQL Injection、XSS）
3. jQuery
4. Bootstrap
5. CSS 預處理器、Webpack
6. 部署


## 11 週

對我來說，擁有知識非常重要的一點就是除魅化。

也不是說有超自然信仰的人都是笨蛋，而是透過系統性的了解內部原理，能一點一點拿回對日子的掌控感——這樣說來相信倒掛晴天娃娃就會下雨的人，也能透過這些行為讓自己好過一點，接下來科學或迷信就是知識正確性 / 可行性的決鬥了。

兩年前曾經有個朋友半夜打電話給我，說他很難過，因為看到我無名小站紀錄的國中經歷的事，讓他很替我難過——可是大，無名小站好幾年前就關了欸——之後他變本加厲開始宣稱能看到我們的健保卡資料、我鎖起來的噗浪，甚至是同步電腦的螢幕畫面。

我當時根本不敢和當事人確認真假，於是偷偷問了工程師前輩：這是有可能的嗎？他說不可能。之後我問了畢業後想轉職工程師的事，對方很認真地替我解惑後，補了一句：「你該不會是因為剛剛那件事才想當工程師的吧？」

才不是勒，我想轉職工程師只是因為我想轉職工程師。

但不可否認的是，我在 11 週學到資安理論時感到十分紓壓。

雖然至今我還是不知道對方採取什麼樣的手段（甚至可能只是虛張聲勢），但恐懼無疑是存在的。 這週拆解了「原來這樣做就可以拿到其它網站使用者的資料！」光是理解其中原理就能舒緩我的不安，就算對方真的滲透我所有帳號，也不會是使用我完全不懂的黑魔法了 XD 這完全是我打算開始學程式時從沒想過的收穫（笑）

然後這週還得到了人生第一個值得參考，不過真正的問題才正要開始。


## 自我檢測

### P1 你知道什麼是雜湊（Hash function）、你知道什麼是加密（Encryption）、你知道雜湊與加密的差別

如果使用者密碼直接被存入資料庫中，只要資料庫直接被偷看（像是在圖書館使用時上廁所忘了換頁），或用其他攻擊方式直接叫出密碼，使用者的資訊安全就會受到威脅，因此存在資料庫中密碼欄位的密碼最好不是原始的樣子。

雜湊和加密都是把原始的明碼輸入轉換成密碼，都是只要輸入字串和加密方法一樣，就可以得到一樣的密碼。

差別在加密是一對一，因此若知道加密規則和輸出結果，就可以回推出原本的明碼，是一對一的關係；但雜湊 (hash) 是多對一的關係，也就是雖然每次輸入都會得到同樣的輸出，但因為不止這組輸入會得到一樣的輸出，因此就算知道加密規則和結果，也無法回推原本是哪個字串，因此安全性又更高。

PHP 中雜湊的語法如下：

	```
	password_hash(<string>, <編碼方式>)
	//可轉換成 hash ，建議存到預留 60 字元以上的欄位
	password_verifty(<明文>, <hash>) 
	//對照兩者是否相同。
	```

### P1 你知道什麼是 SQL Injection 以及如何防範

SQL Injection 是在輸入的字串中夾帶 SQL 的語法，又因為字串拼接設計不良，夾帶進去的內容被當成 SQL 語法的一部份執行而導致的資安漏洞。以下舉個例子：

程式碼如下：

	```
	$sql = sprintf("INSERT INTO comments(username, content) VALUES('%s', '%s')", $_POST['username'], $_POST['content']);
	```

只要我在 content 的欄位輸入 `'), ('not_me', (select password from users));#` ，就會變成這樣：
	
```
	$sql = INSERT INTO comments(username, content) VALUES('me', ''), ('not_me', (select password from users));#')
```
	
因為 `#` 後面會變成附註，因此變成新增兩條留言，第二條的 username 和 content 附註，其中內容甚至可以叫出所有用戶的資料。超危險。

**解決方法：使用 SQL 內建機制拼接**

```
$sql = 
// 這邊預留空間的方法是用問號 '?'
$stmt = $conn->prepare($sql) ;
// 先準備好
$stmt->bind_param('<拼接什麼>', $<變數1>, $<變數2>) ;
// 如果要拼接兩個字串，就用 'ss' ，整數的話就是 'i'
$result = $stmt->execute()
// 執行 query
// 接著用原本的判斷式檢測是否執行成功

$result = $stmt->get_result()
//這樣才算拿到結果
```


### P1 你知道什麼是 XSS 以及如何防範
XSS 全名 `Cross-Site Scripting` ，也就是跨網站執行 JavaScript。例如顯示留言的地方的 HTML 如下：

```
<div class='content'><?php echo $row['content']?><div>
```

這時只要使用者輸入 html 或 JavaScript 語法，例如 `<script>alert('hacked')</script>` ，就會直接被解讀為程式碼的一部份並被執行。

**防範方法：字元跳脫**

函式 `htmlspecialchars()` 可將 html 的特殊符號轉換成純文字。

值得注意的是，因為資料庫儲存原始資料就好，因此建議在輸出處使用。另外，因為不知道攻擊會從哪裡來，因此建議所有輸出都使用字元跳脫。

### P1 你知道為什麼儘管前端做了驗證，後端還是要再做一次驗證

因為前端的驗證只針對瀏覽器畫面上的驗證，但除此之外還有許多漏洞，例如不透過瀏覽器發 request 給後端即可繞過。通常簡單如「是否有東西漏填」這種驗證會給前端，而和資安相關的例如身分驗證則由後端負責。 

### P2 你知道什麼是 CSRF 以及如何防範
參考資料：
[讓我們來談談 CSRF](https://blog.techbridge.cc/2017/02/25/csrf-introduction/)
[[week 11] 資訊安全 - 雜湊與加密 & 常見攻擊：SQL Injection、XSS](https://github.com/heidiliu2020/This-is-Codediary/blob/week11/week11_%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8_%E9%9B%9C%E6%B9%8A%E8%88%87%E5%8A%A0%E5%AF%86%E3%80%81%E5%B8%B8%E8%A6%8B%E6%94%BB%E6%93%8A.md)

CSRF 的全名是 `是 Cross Site Request Forgery`（跨站請求偽造）。也被稱為 one-click attack 或 session riding。簡單來說就是「在不同 domain 下，偽造使用者本人發出的 request」。

平時登入網站後會得到一組 SESSION ，之後就算離開該網站，瀏覽器還是會幫你在 COOKIE 中保留 SESSION 一段時間。此時如果有個釣魚網站騙你在不知情的情況下，對該網站送出 Request （例如放在按鈕或圖片中），此時因為瀏覽器還留著你的 SESSION ，該網站以為是合法請求並接受，這樣一來釣魚網站就可以用你的身分在該網站進行操作。

**不同層面的防範辦法**

對使用者端來說，最好懂的就是隨時清空 SESSION，不過這就代表每次都要重新登入，很麻煩。

Server 端可以進行雙重驗證，像是輸入驗證碼就很直接，但每個動作都要輸入一次驗證碼有點麻煩，因此最好的方法是多加一層雙重認證。可以用表單中夾帶 CSRF token ，資料確認時也要保證其有被帶上才執行，產生和儲存都由 Server 端負責，但如果攻擊者先發出 request 就可破解；第二種方法是 Double Submit Cookie ，利用「cookie 只會從相同 domain 帶上來」的特性，把資料存在使用端，但只要攻擊者掌握任何 subdomain 就可破解；最後一種是由 Client 產生 token ，同時放到表單和 cookie 中。

瀏覽器方面， Chrome 也有提供 SameSite cookie 幫 cookie 加上一層驗證。
 


## 12 週

![](https://i.ibb.co/y5d3jG3/5-4136.jpg)

從 11 週到 12 週，獨立架好一個網站十分有成就感，雖然常常在 PHP 和 HTML 中迷路，或是 JavaScript 動不動就不鳥我，不過說不定是目前（cosplay 15 週的目前）為止我最享受課程的兩週了。

參加過的新竹和台南的地方小聚，助教都有提到這期課程設計會不會太手把手的問題。同時這兩週也有大量的課程檢討影片，還特別說明寫完再來看——我幾乎沒有看（喂）而且課程影片可以的話我都會先暫停自己試試看，繼續如果和呼哩做得差不多就會有種贏了的感覺，用精神勝利法讓自己有動力繼續往前的概念。

不過也開始思考，課程結束後我還能繼續成長嗎？因為目前都只有跟課而且沒做挑戰題，雖然這週因為課程規劃上已經寫了好幾週 PHP ，現在忽然要把 JS 撿回來，有些寫法常常會忘記或搞混，但都能靠搜群引擎化險為夷，看起來是多了點自信，不過對於自己是否有能力獨自學習一個新工具感到有點擔心。

另一組令人感到踏實的事件，是我這週挑戰回同學在 Slack 上的問題。雖然有些看起來是幫倒忙，但也算是踏出一步了。不知為何我一直對「成為有求知慾的人」有迷之執著，常常會焦慮自己是否不求甚解。這幾次不管幫忙或被幫忙 debug 雖然當下沒有自覺，回神過來自己已經深陷其中了，發現的時候感覺，好爽～～～

……但是，這週並沒有拿到值得參考。

我對自己的了解準確到，連我自己都嚇一跳的地步。前陣子（上個月？）看到大家在討論值得參考的問題時，心想：「看看我都沒拿過值得參考，還不是活得好好ㄉ XD」不過正是因為無欲無求才沒有痛苦。11 週毫無預兆的拿到一次值得參考時心想，完了，我也是嘗過值得參考滋味的人了。聽有在化妝的朋友說，如果用過專櫃就很難回開架了，人只會越來越難滿足，也許值得參考是這樣。總之做出「我完蛋了」的預言後，今天看同學作業時就迎來反撲，陷入強烈腫脹到有點疼痛的情感中無法動彈——**好不甘心！！！**

不過現在回頭看也不完全是壞事，畢竟在此之前無動於衷也超不合理，就像是直接投降一樣，說難聽點也只是鴕鳥心態替自己的失敗找藉口而已吧。反之不甘心的心情也許才是真正站上起點，並且開始對自己負責的象徵嗎？我覺得很有趣，希望能找到和這份心情共處的方式，並轉化為己所用。


## 自我檢測

### P1 你知道什麼是 SPA
 `Single Page Application` 簡稱 SPA ，單介面應用程式，顧名思義就是所有動作都在一個頁面上完成，不會重新導向 index.html 以外的地方。其原理是 JavaScript 用 Ajax 動態從 Server 端拿資料，再即時 render 到 client 端上。
 
 **優點：**
1. 使用者體驗較佳。每次動態更新資料只會更新部分頁面，而不是導向完全不同的頁面。
2. 前後端分工較明確。後端負責提供 API 給前端 render。
3. 就算 JS 掛掉， HTML 檔案還是會顯示基本的畫面而非直接掛掉。

**缺點**
1. 一個頁面要載入超多 .js 檔案，會跑比較慢。
2. SEO 差。因為真正的內容要等 JS 渲染完，比較笨的爬蟲只看到 HTML 的話就是個空殼 → 可靠 SSR 解決。
3. 前端變的超級複雜，還會有回傳順序的問題。要是沒寫好可能會出現「明明都點到第三頁了，卻顯示第一頁的畫面」這種狀況。
 
### P1 你知道怎麼樣用 PHP 自己寫出 API
PHP 基礎語法：
```
// 建立一個空陣列
$json = array();
// 在陣列中增加一個新的物件
$array_push($json, array(
	"id" => 13         
));
// 轉換成 json 格式
$response = json_encode($json);	
// 印出來看看
echo $respons;
// 結果 [{"id": 13}]
```

之後前端只要讀取 PHP echo 的 JSON 格式結果就好。

 ### P1 你知道如何在前端與自己開的 API 串接
 串接 API 的方法有很多種，以下示範用 jQuery 實作 Ajax 的方法：
 ```
 $.ajax({
    method: 'GET',
    url: 'https://'
}).done(function(data) {
    console.log(data)
}).fail(function(err)) {
    console.log(err)
})
 ```
 
或是

```
$.ajax({
    method: 'GET',
    url: 'https://',
    success: (data) => function,
    error: (err) => functuon
})
```


### P1 你知道在 server 與在 client render 的差別
**server**
- PHP拿出資料 → render 到 HTML 上 → 回傳 HTML 檔案給瀏覽器。
- 以上流程每進行一次就會刷新一次頁面。

**client render**
- PHP 拿出資料 → 變成特定格式(JSON) → 傳給 JavaScript → JavaScript render 到沒有資料的 HTML 上。
- 以上流程並不會更換頁面， PHP 只負責回傳 API 給前端，再由前端動態 render 到頁面上。
- 優缺點可參照上面 SPA 的條目。

也來借用 minw 助教提供的圖解：
![](https://user-images.githubusercontent.com/10834433/92352316-6422e280-f110-11ea-8b0d-fc29ef8fb4cf.png)

 ### P1 你知道 jQuery 是做什麼的
jQuery 是 JavaScript 的 library ，將常用的函式包在一起。早期瀏覽器和寫法都未被統一， jQuery 可以跨瀏覽器的特性是很大的優勢，也提供了更為簡潔的語法。
 
### P1 你知道 jQuery 與 vanilla js 的差別
vanilla js 就是原生 JavaScript 。而 jQuery 則是以此為基礎建立的 library ，使用前要先引入檔案才能使用。前端發展至今大專案已經有更好維護的框架了，不過較小的專案使用 jQuery 自由度反而較高。

 ### P1 你知道什麼是 Bootstrap、P2 你知道 Bootstrap 原理及如何應用
Bootstrap 是一個由 HTML、CSS 和 JavaScript 寫成的前端框架，核心的設計目標是達成RWD響應式與行動優先，也就是讓你的網站排版可以自動適應螢幕大小。

使用 Bootstrap 前要先引入檔案，其中設定好各種 CSS 樣式和 JavaStript 樣式，想使用時只要更改 HTML 中的 class 即可。

雖然 Bootstrap 提供各種 UI 對不善設計的工程師是一大福音，不過也因此出現了大量相似的網頁 XD


## 13 週

動力急速下降的一週。

可能是這週的內容忽然變得有點發散，也不太可能真的從零把什麼東西蓋起來，或是真的不看影片獨自把 webpack 架好。雖然說是之後會越來越明白的，但還是有點空虛啊。而且這週還必須帶著上週混亂的心繼續前進。

之前有人提到跟課程像是修行，我覺得非常有道理。

前幾年曾為了「理解後才能理直氣壯的討厭」，而加入校內的中國哲學讀書會，總體來說根本沒讀到什麼書算是個浪費時間的努力，不過人品超差的老師偶爾還是會說出讓我有一點點點點收穫的東西，像是「注重禮節是由外而內的改造過程」。在此之前，我想像中的理想行動是，內心有滿滿的衝動，以此為燃料付諸實踐，甚至不允許一點雜質，因此我當下非常不諒解老師說的話——不重視真心的行為，根本只是政治手段而已吧。

雖然恥於承認，但我想我慢慢可以理解了。與其說是認同這個價值觀，應該說偶爾有採取此策略的必要性。

就像是練體能好了，就絕對不會有人懷疑「我真的適合追求更好的體型嗎？」或是「我真的喜歡生酮飲食嗎？」很多時候我們什麼都不想，就只是做，雖然內心會有非常非常多自我懷疑，但抱著這些迷惘繼續行動，某天回神過來發現自己又前進了一步而發自內心感到開心，就是邁向目標的起點了。雖然很痛苦，但如果因為自我懷疑就停下腳步也太可惜了。

雖然學到 13 週又很多被程式搞到瘋掉或自我懷疑的時刻，但無法否認得到的快樂就像原石一樣在那裡閃閃發亮，為了這些時刻就再多走一段吧……修但幾勒，忽然又開始灌雞湯。唉呦反正我現在因為寫程式感到焦慮不安的時候，就會很中二的認為「畢竟是在修行嘛」然後多撐一下。


## 自我檢測

### P1 你知道 webpack 的目的以及原理

Webpack 是一種 module bundler ，也就是可以將各種資源打包在一起，讓你可以在瀏覽器使用它。

之前使用 node.js 時，如果要將檔案外的模組（例如另一個檔案寫好一個功能後輸出）引入，可以使用 `require`。但這個語法和瀏覽器不相容，相對的瀏覽器要使用 `<script src='目標檔案'>` 引入作為全域變數，但若一次引入不只一個檔案，可能會發生變數名稱衝突，此時就必須使用 jQuery 提供的 .conflic() 排除。

既然沒有支援就自己寫ㄅ，於是就出現各種非官方的模組化規範，直到最近出現 ES6 規範。不過 ES6 的規範支援度還是不好，例如必須開 Server 、 必須在引入時標註 `type="module"；` 而且在想要引入其他人寫的套件時，必須將整份 `node_modules` 傳上去，或是在 import 輸入完整路徑，十分不好維護。

使用 Webpack 可以將所有檔案包成一個 main.js ，這樣瀏覽器只要引入就好了。更甚者它將模組的概念向外延伸至各種資源，像是 CSS 或圖片，再經過 loader 將資源打包成 .js 檔給瀏覽器使用。

 ### P1 你熟悉如何使用 webpack 進行模組化開發
 
 不太熟悉（喂）
 
 以下簡單列一下使用自己的模組的基本流程好ㄌ：
 
 1. 在專案資料夾內安裝 webpack
	 ```
	 npm init -y // 初始化 npm
	 npm install webpack webpack-cli --save-dev // 安裝
	 ```
 2. 設定 `webpack.config.js` ，最基本設定如下：
	 ```
	 const path = require('path');

	module.exports = {
	  mode: 'production',  // 預設是production(壓縮代碼)， development 指定為開發環境(未壓縮代碼)
	  entry: './src/index.js', // 從哪裡引入模組
	  output: {
		filename: 'main.js', // 輸出之後放到哪裡
		path: path.resolve(__dirname, 'dist'),
	  },
	};
	 ```
3. 設定 `package.json`
	```
	"scripts": {
		"build": "webpack", // 之後輸入 npm run build 時就會跑 webpack ㄌ
		"test": "echo \"Error: no test specified\" && exit 1"
	  },
	```
4. 在檔案使用 `require` 和 `export` 進行模組的輸入和輸出
5. `npm run build` 跑起來！

另外在使用外部模組和 Loader 時，也是遵循安裝 → 更改設定檔和指令的方法。


### P1 你知道如何使用 Promise、P2 你知道如何使用 fetch
資料來源：[MDN - fetch](https://developer.mozilla.org/zh-TW/docs/Web/API/Fetch_API/Using_Fetch) 、 [MDN - Promise](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Using_promises)

在 JavaScript 上想發非同步的 request 時，除了使用 XMLHttpRequest 以外，也可以使用 fetch 讓程式更簡潔。

最基本的語法是：
```
fetch('url')
```

之後如果要加 header 或其他設定可以用物件形式放在第二個參數中。另外，如果要 POST 的話，`body` 中的 content type 必須符合才行。

值得注意的是，因為 fecth 的回傳值不會 reject HTTP 的 error status ，因此之後還要額外偵測 status 才不會出現錯誤。另外， fetch 雖然可以接收跨站的 cookies ，卻不會主動傳送 cookies 。

fetch 出來的結果會以 Promise 形式出現，必須用 `.then(cb)` 才能取得其中內容。

`Promise` 是一個表示非同步運算的最終完成或失敗的物件。因此自己建立一個 Promise 必須輸入兩個函數：成功和失敗的值，而且通常只會有一個被觸發。以下是示意：

```
function init(resolve, reject) {
	resolve(3);
	reject(5);
}

const myPromise = new Promise(init)

myPromise.then((data) => {
	console.log(data) // 如果成功就跑出 3
}).catch((err) => {
	console.log(err) // 有錯誤的話就跑出 5
})
```


### P2 你知道 gulp 的目的以及原理

glup 是一套 `task manager` ，將任務集中管理並設定執行流程。其中 task 的類型可以有很多種，也可以自訂功能。


### P2 你知道 CSS Sprites 與 Data URI 的優缺點

參考資料：[使用 DATA URI 將圖片以 Base64 編碼並內崁至網頁中，加速載入速度](https://blog.gtwang.org/web-development/minimizing-http-request-using-data-uri/)

`CSS Sprites` 是為了避免每次顯示一張圖就要發一次 HTTP request ，乾脆將所有小圖放在一張大圖上一次拿進來。顯示個別小圖的原理是先顯示大圖並設定成小圖的大小、設定成不重複，再位移到指定位置。這麼做的好處是全部只要載入一張圖，降低網路載入時間；但缺點是拼圖再選取的調整比較麻煩、不易維護，也不方便 SEO 讀取。

`Data URI` 是一種檔案格式，其資料全部都是經過 base64 編碼之後，以文字的方式來儲存的。優點是可以減少 HTTP 請求的數量，直接寫進 HTML 或 CSS 中，不需要透過外部的檔案儲存；不過維護時若要修改就要重新編碼，無法快取且易讀性很差，對 SEO 同樣不友善。


 ### P2 你知道什麼是 uglify 與 minify

 參考資料：[wiki - 極簡化](https://zh.wikipedia.org/wiki/%E6%A5%B5%E7%B0%A1%E5%8C%96)
 
`minify` 是在不影響功能的情況下，移除所有非功能性必要之原始碼字元，例如換行、空白、變數和函式名稱縮短之類，在不會影響運作的前提下將檔案縮小。

`uglify` 則是除了壓縮外，還會混淆程式碼，讓程式變得難以被人閱讀，可作為隱藏商業邏輯的手段。
 
 
 ### P3 你熟悉如何使用 gulp 建構自動化工作流程
 
 不知道（等等），以下紀錄跑 SASS 的方法，列一下在設定檔 `gulpfile.js` 要做的事：
 
 ```
 const { src, dest } = require('gulp');
const sass = require('gulp-sass');
sass.compiler = require('node-sass');

function defaultTask() {
  return src('src/*.scss') // 輸入這個檔案
    .pipe(sass().on('error', sass.logError))
    .pipe(dest('./css')) // 輸出成這個檔案
}

exports.default = defaultTask;
 ```

 
### P3 你知道 CSS 優化的一些小技巧

前端的 CSS 優化主要分成三個方向：

1. 資源大小
	- minify：上面介紹過了。
	- gzip：用重新編碼的方式壓縮，此時瀏覽器已經看不懂了，必須經過解碼才能解讀。主要由後端負責。
2. 載入方式
	- CSS Sprite ：上面介紹過了，將小圖拼成大圖一起載入再分別呈現。
	- Critical CSS：全部都要載入太慢了，先載入重要的部分。最簡單的作法是直接放至 .html 檔中。
	- Cache：將傳過的東西放在 client 端。主要由後端負責。
3. 執行方式
	- CSS 選擇器：需要另外做判斷的 CSS Selector 較複雜，從 SASS 轉到 CSS 可能會變複雜，要注意。
	- 屬性渲染：有些屬性可能會造成大規模重繪，例如用 `top` 定位不如用 `transform` ，因為前者定位是用 layout 會牽扯較多東西。


## 14 週

卡到爆的一週。

在此之前還曾經對後端工程師有過幻想，覺得能只用 CLI 好帥，經歷十四週後完全不敢想自己現在能勝任後端工作。

真正體悟出會在部屬時那麼卡的原因，以及其和我本人性格間的關係，是在 17 週的時候。為了好好扮演 15 週的生菜，這週的心得就用對課程制度的反饋覆蓋好了：

**每日進度**

課程每日進度，是要求學員每天紀錄當天完成的進度、學到的東西、和明日預計進度等等。

請讓我在此引用 `lauviah0622` 同學精準的心得：（已得到授權）

> 不會有一定要寫很長之類的壓力，然後可能還會不經意地被人看到滿足虛榮心，那種有點暴露，但是又其實沒人理你的感覺有點上癮（幹超變態的）。

我個人認為這完全點出該制度的精妙之處。不知道有誰讀過、沒有按讚系統，唯一就是點 icon 到 slack 私訊當事人，完全適合容易被社群軟體綁架的我。還可以快樂地使用韓國瑜思維：門檻那麼高，沒有表達反感的人一定都是蠻喜歡我的每日進度的啦 (?????) 

另外也蠻感謝沒有人阻止我一直在每日進度寫一些和 coding 無關的紀錄。不過，雖然看似無關緊要的廢話，卻也扎扎實實的讓我能夠更穩定的學習。有點像過動的孩子會被送去游泳一樣，每天開始學習前，將腦內過多的思考再檢視整理並記錄下來，互動不高不用擔心被綁架但依然可以滿足表現欲，然後就可以專心學習了 。也有學習中出現無數次很想放過自己「算了今天就這樣吧」，但因為前一個進度報告已經承諾過的進度還沒達到，想到這樣明天就要說抱歉我食言而肥——太羞愧了真是太羞愧了！多努力一點吧！然後充滿決心的狀況也有 XD

**助教們的 Podcast**

去年九月畢業後，我正式般到台南。

前陣子臉書動態回顧說，當時的我寫了胡遷《大象席地而坐》的句子：

> 我告訴你最好的狀況，就是你站在這裡，你可以看到那邊的那個地方。你想著那邊一定比這裡好，但你不能去。你不去，才能解決好這的問題。

我還沒當過正職，甚至人生還有很多經歷空缺，這種時候只能依著想像行事——當初我想像我到台南後就會自動找到人生方向，現在我想像要是轉職成為工程師，會不會還是無法融入想像的社會，或是所有問題都迎刃而解，最好是連膝蓋的舊傷都自己好了。

而課程助教每週的 podcast ，在這之中也許就扮演某種教練的角色。

除了「工作的煩惱會是這樣」的想像外，最重要的果然還是「原來工程師長這個樣子」……不對，應該說是對「就算是這樣的人，還是可以持續追求優雅的生存方式啊」的想像——覺得這不重要的人，去給我和《炎拳》的賀利田說啊（爆雷王）

另外也在 15 週左右上了 Podcast。雖然對自己不太滿意，但反正我是無論如何都不可能對自己滿意的人，重點是整體而言是個有趣的體驗，是那種我老年時纏著來幫忙打掃的社工喋喋不休時，會反覆體起的經驗（不要用這麼難以理解的情境說明！）

## 自我檢測

 ### P1 你知道虛擬空間、虛擬主機以及實體主機的差別
 
 資料來源：[60秒，搞懂虛擬主機、VPS、實體主機間的差異](https://wanteasy.com.tw/blog/difference-between-shared-vps-dedicated-hosting)
 
`Dedicated Hosting` 實體主機就是我們現在用的電腦的主機，如果用實體主機當伺服器的話，除了要像這週部屬時要裝好作業系統和架網路線外，維護起來也有點麻煩，尤其是一旦關機別人就進不來了 XD
 
`Shared hosting` 虛擬主機則是在遠端有台實體主機，然後切出不同的空間作為不同伺服器，但還是共用 CPU 、記憶體和硬碟，想像成宿舍有各自房間和公共空間那樣。雖然比實體主機方便維護，也較便宜，但缺乏獨立性，而且要是你鄰居習慣很差（像是流量大爆），你的伺服器就很容易不穩或當機。

`Virtual Private Server` ，也就是常聽到的 VPS也是大家共用一台主機，透過虛擬化技術把一台電腦硬體切成很多帳號，讓每個VPS帳號可以安裝自己的作業系統、軟體、自己管理。因為硬體成本還是大家一起均分，所以跟實體主機比起來，VPS的費用頓時也變低了～
 
 ### P1 你知道什麼是網域（Domain）
 
 Domain 全名是 `Domain Name` ，算是 IP 位置的代稱，方便人們閱讀。
 
 
 ### P1 你知道如何設定網域（A、CNAME）
 
 資料來源：[PM筆記：HTTPS、A紀錄與CNAME](https://medium.com/%E4%B8%80%E5%80%8B%E4%BA%BA%E7%9A%84%E6%96%87%E8%97%9D%E5%BE%A9%E8%88%88/pm%E7%AD%86%E8%A8%98-https-a%E7%B4%80%E9%8C%84%E8%88%87cname-91f6f2a1ee2f)
 
 A 是 `Address` 。可以想像成 IP 位置是詳細地址，而域名則是建築物名。買好域名後 A 就是定位這棟建築物在哪裡，之後使用者輸入域名就會自動導向 A 的位置。
 
 CNAME 全名是 `Canonical Name` ，是關連名稱與地點，其會指到一個網域名稱。用建築物來比喻可能是不同的餐廳（CNAME）都在同的大樓（網域）內，那不管我和司機說想去其中哪家餐廳都會自動被載到該大樓了。
 
 
 ### P1 你知道如何用 SSH 遠端連線到自己的主機、P1 你知道如何部署應用程式
 
 知道……吧（眼神飄忽）
 
 
 ### P2 你知道什麼是 No SQL
 
 參考資料：[了解NoSQL不可不知的5項觀念](https://www.ithome.com.tw/news/92506) 、 [網站部署](https://hackmd.io/VP6Jq8d0Ru-jVGiO94w-Yw?view)

無論是 SQL 或 NoSQL 指的都是拿來查詢資料庫的語言，而非資料庫系統。

#### 關聯式資料庫 SQL
- 儲存格式為 table （像是表格那樣）
- table 之間互相關聯（例如 id 都一樣）
- 結構穩定，但相對彈性低。
- Transaction 遵守 ACID 。
- 常見如 MySQL、PostgreSQL、Microsoft SQL Server、SQLite

#### 非關聯式資料庫 NoSQL
- Not Only SQL
- 用不同型態儲存，因此資料可放的型態也更多元（例如陣列）
- 結構較不明顯，因此彈性更高，適合搜集數據。
- 相對的，查詢資料也比較慢。
- 使用 key-value 存資料，可以想像成 JSON。 
- 具有水平擴充能力，只要增加新的伺服器節點，就可以不斷擴充資料庫系統的容量。
- Transaction 遵守 CAP 。
- 常見如 mongodb。
 
 ### P2 你知道什麼是 Transaction 與 lock
 
 Transaction 指的是一組一次牽涉到多個  query 的操作，實際應用例如轉帳和購物。例如交易的時後小明給小美一百塊，這意味著小明少了一百，而小美多了一百這兩個操作。

此時只有兩個人還好，但使用者一多像是搶購票券之類的就會出問題，因為多筆資料同時進行更改時可能造成互相影響，比如說只有十張票卻有一百個人搶，發生 race condition ，最後發生超賣情形。

要避免這種狀況，只要在有人交易時先把門鎖上或放個標示說：「裡面有人ㄛ~」就可以避免了，這就是資料庫的 lock 。回到資料庫，為了維持 Transaction 的一致性（consistency）和隔離性（isolation），我們可以在資料被讀取或寫入時掛上一個 lock （像是公眾廁所燈有人使用時就會亮），其他 transaction 可以決定是否要等待或依然讀取。
 
 
### P2 你知道資料庫的 ACID 是什麼

參考資料： [維基百科 - ACID](https://zh.wikipedia.org/wiki/ACID)

Transaction 是指由一系列資料庫操作組成的一個完整的邏輯過程，為了保證 Transaction 的正確性，要符合以下四個特性：
- 原子性 atomicity：要嘛全部失敗，要嘛全部成功。可以想像匯款的時後只有成功（錢過去了）或失敗（錢沒過去），不會出現這邊錢減少但那邊卻沒增加的情形。如果過程中發生錯誤，則會退回開始前的狀態，就像什麼都沒發生一樣。
- 一致性 consistency：維持資料的一致性。也就是錢的總數相同。
- 隔離性 isolation：多筆交易不會互相影響，比如說不能同時改同一個值，詳細作法可看前兩題。
- 持久性 durability：交易成功之後，寫入的資料不會不見，就算系統故障也不會消失。


 ### P3 你知道什麼是資料庫的 View 以及使用時機
 
 View 是一張虛擬 table ，只能讀取不能改寫，好處是方便檢視不同 table 的特定欄位，在開放資料庫給他人時也方便隱藏比較機密的欄位，不過缺點是不易維護。
 
```
CREATE VIEW view_name [(column_list)] AS
SELECT column_name(s)
FROM table_name
WHERE condition;
 ```
 
 
 ### P3 你知道什麼是 Stored procedure 以及如何使用

SQL 的 function 有分兩種，一種是內建函式例如 `SUM()` ，另一種則是 Stored procedure ，其設定完後可以直接取代 query 。
```
DELIMITER //
CREATE PROCEDURE functionName()
  BEGIN 
    SQL query;
  END //
DELIMITER ;
```

`DELIMITER` 是設定換行符號，先設定成 `//` 才不會和 Stored procedure 中的 query 撞到。

之後要使用 Stored procedure 就用 `CALL functionName()` 就可～


 ### P3 你知道資料庫的 Trigger 以及使用時機

資料來源：[維基百科 - trigger](https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93))

Trigger 的用於記錄資料庫的變動，並用 table 將變動記錄下來。

```
delimiter //
CREATE TRIGGER 名稱
    BEFORE UPDATE FROM table名稱
    FOR EACH ROW
  BEGIN 
    要做什麼;
  END //
  delimiter;
```


## 結語

我：這次寫三百字就好了。
也是我：（也了三千字）

這次的心得內容和之前比起來發散好多，看起來我就是一個很愛碎碎念的人而已（說得好像本來不是一樣），好不滿意ㄛ……算了我要繼續往前了，20 週心得見～

### 跨題目資料來源
 
同學們的自我檢測：
 
 [Nicolacha](https://github.com/Lidemy/mentor-program-4th-Nicolakacha/pull/29/files)
[awu](https://github.com/Lidemy/mentor-program-4th-awuuu0716/pull/18/files?short_path=d5209b1#diff-515aba90d9fdcb37d43a64182f10f1ae)
[Ruofan](https://hackmd.io/VP6Jq8d0Ru-jVGiO94w-Yw?view)